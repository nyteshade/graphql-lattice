{"version":3,"sources":["../es6/GQLEnum.js"],"names":["_MODEL_KEY","_PROXY_HANDLER","ENUMS","GQLEnum","GQLBase","constructor","enumValueOrKey","requestData","Class","enums","symbol","enumVK","value","getModel","name","undefined","NaN","GQL_TYPE","GraphQLEnumType","values","valueFor","deprecationReason","description","result","map","ast","SCHEMA","array","Proxy","GenerateEnumsProxyHandler","astValues","definitions","error","ll","enumDef","defKey","symObj","Object","sym","valueOf","set","push","get","obj","key","has","isFinite","length","apiDocs","DOC_CLASS","DOC_FIELDS","joinLines"],"mappings":"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","file":"GQLEnum.js","sourceRoot":"es6","sourcesContent":["/**\n @namespace GQLInterface\n @flow\n */\n\nimport { GQLBase } from './GQLBase'\nimport { GraphQLEnumType, parse } from 'graphql'\nimport { Getters } from './decorators/ModelProperties'\nimport { LatticeLogs as ll } from './utils'\n\n/* Internal Symbol referring to real accessor to GQLBase model object */\nconst _MODEL_KEY = Symbol.for('data-model-contents-value');\n\n/* Internal Symbol referring to the static object containing a proxy handler */\nconst _PROXY_HANDLER = Symbol.for('internal-base-proxy-handler')\n\n/* Internal Symbol property referring to the mapping of values on the GQLEnum */\nconst ENUMS = Symbol();\n\n/**\n * GraphQL Enum types can be a bit picky when it comes to how scalar types\n * equate to enum values. Lattice makes this easier by allowing you to specify\n * a value or the key when your enum has a value other than the key; GraphQL\n * does not allow this by default.\n *\n * Further more, when instantiating a GQLEnum type, you can pass a string or\n * value matching the enum key or value or you can pass an object with key of\n * value and the value being either the enum key or value. If any of those\n * things match, then your `instance.value` will equate to the enum's key. If,\n * on the other hand, your supplied values do not match then `instance.value`\n * will be `null`.\n *\n * @class GQLEnum\n */\n@Getters('symbol')\nexport class GQLEnum extends GQLBase {\n  constructor(enumValueOrKey: ?Object, requestData: ?Object) {\n    super({}, requestData)\n\n    const Class = this.constructor\n    const enums = Class.enums;\n    let symbol;\n    let enumVK: (Object | string | null) = enumValueOrKey || null\n\n    // @ComputedType\n    symbol = enums[enumVK] || enumVK && enums[enumVK.value] || null\n\n    Object.assign(this.getModel(), {\n      name: symbol ? symbol.name : null,\n      value: symbol ? symbol.value : null,\n      symbol: symbol ? symbol : null\n    })\n  }\n\n  /**\n   * Retrieves the actual symbol stored name property from the internal\n   * model object for this enum instance. That is a mouthfull, but it\n   * basically means that if your enum is something like:\n   *\n   * ```\n   * enum Person { TALL, SHORT }\n   * ```\n   *\n   * and you create an instance using any of the following\n   *\n   * ```\n   * p = new Person('TALL')\n   * p = new Person(valueFor('TALL'))\n   * p = new Person({value: 'TALL'})\n   * ```\n   *\n   * that your response to `p.name` will equate to `TALL`.\n   *\n   * @method ⬇︎⠀name\n   * @memberof GQLEnum\n   * @return {mixed} typically a String but any valid type supplied\n   */\n  get name(): mixed {\n    const name = this.getModel().name\n\n    return (\n      name !== undefined &&\n      name !== null &&\n      name !== NaN\n    ) ? name : null;\n  }\n\n  /**\n   * Much like the `.name` getter, the `.value` getter will typically\n   * retreive the name of the enum key you are requesting. In rare cases\n   * where you have defined values that differ from the name, the `.value`\n   * getter will retrieve that custom value from the `.value` property on\n   * the symbol in question.\n   *\n   * This should do the right thing even if you instantiated the instance\n   * using the name.\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀value\n   * @return {mixed} the value of the enum type; this in all likihood should\n   * be a String or potentially an object\n   */\n  get value(): mixed {\n    const value = this.getModel().value\n\n    return (\n      value !== undefined &&\n      value !== null &&\n      value !== NaN\n    ) ? value : null;\n  }\n\n  /**\n   * Determines the default type targeted by this GQLBase class. Any\n   * type will technically be valid but only will trigger special behavior\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀GQL_TYPE\n   * @static\n   * @const\n   *\n   * @return {Function} a type, such as `GraphQLObjectType` or\n   * `GraphQLInterfaceType`\n   */\n  static get GQL_TYPE(): Function {\n    return GraphQLEnumType;\n  }\n\n  /**\n   * Each instance of GQLEnum must specify a map of keys and values. If this\n   * method returns null or is not defined, the value of the enum will match\n   * the name of the enum as per the reference implementation.\n   *\n   * Example:\n   * ```\n   *   static get values(): ?Object {\n   *     const { valueOf } = this;\n   *\n   *     return {\n   *       NAME: valueOf(value)\n   *     }\n   *   }\n   * ```\n   *\n   * @method ⬇︎⠀values\n   * @memberof GQLEnum\n   * @static\n   *\n   * @return {Object|Null} an object mapping with each key mapping to an object\n   * possessing at least a value field, which in turn maps to the desired value\n   */\n  static get values(): Object {\n    return {};\n  }\n\n  /**\n   * Shorthand method to generate a GraphQLEnumValueDefinition implementation\n   * object. Use this for building and customizing your `values` key/value\n   * object in your child classes.\n   *\n   * @memberof GQLEnum\n   * @method valueFor\n   * @static\n   *\n   * @param {mixed} value any nonstandard value you wish your enum to have\n   * @param {String} deprecationReason an optional reason to deprecate an enum\n   * @param {String} description a non Lattice standard way to write a comment\n   * @return {Object} an object that conforms to the GraphQLEnumValueDefinition\n   * defined here http://graphql.org/graphql-js/type/#graphqlenumtype\n   */\n  static valueFor(\n    value: mixed,\n    deprecationReason: ?string,\n    description: ?string\n  ): Object {\n    const result: Object = { value }\n\n    if (deprecationReason) { result.deprecationReason = deprecationReason }\n    if (description) { result.description = description }\n\n    return result;\n  }\n\n  /**\n   * For easier use within JavaScript, the static enums method provides a\n   * Symbol backed solution for each of the enums defined. Each `Symbol`\n   * instance is wrapped in Object so as to allow some additional properties\n   * to be written to it.\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀enums\n   * @static\n   *\n   * @return {Array<Symbol>} an array of modified Symbols for each enum\n   * variation defined.\n   */\n  static get enums(): Array<Symbol> {\n    // @ComputedType\n    if (!this[ENUMS]) {\n      const map: Map<*,*> = new Map();\n      const ast = parse((this.SCHEMA: any));\n      const array = new Proxy([], GQLEnum.GenerateEnumsProxyHandler(map));\n      const values = this.values || {};\n      let astValues: Array<any>;\n\n      try {\n        // TODO: $FlowFixMe\n        astValues = ast.definitions[0].values;\n      }\n      catch (error) {\n        ll.error('Unable to discern the values from your enums SCHEMA')\n        ll.error(error)\n        throw error;\n      }\n\n      // Walk the AST for the class' schema and extract the names (same as\n      // values when specified in GraphQL SDL) and build an object the has\n      // the actual defined value and the AST generated name/value.\n      for (let enumDef of astValues) {\n        let defKey = enumDef.name.value;\n        let symObj: Object = Object(Symbol.for(defKey));\n\n        symObj.value = (values[defKey] && values[defKey].value) || defKey;\n        symObj.name = defKey\n        symObj.sym = symObj.valueOf()\n\n        map.set(symObj.name, symObj)\n        map.set(symObj.value, symObj)\n\n        // This bit of logic allows us to look into the \"enums\" property and\n        // get the generated Object wrapped Symbol with keys and values by\n        // supplying either a key or value.\n        array.push(symObj)\n      }\n\n      // @ComputedType\n      this[ENUMS] = array;\n    }\n\n    // @ComputedType\n    return this[ENUMS];\n  }\n\n  /**\n   * Due to the complexity of being able to access both the keys and values\n   * properly for an enum type, a Map is used as the backing store. The handler\n   * returned by this method is to be passed to a Proxy.\n   *\n   * @method GQLEnum#GenerateEnumsProxyHandler\n   * @static\n   *\n   * @param {Map} map the map containing the key<->value and\n   * value<->key mappings; the true storage backing the array in question.\n   * @return {Object}\n   */\n  static GenerateEnumsProxyHandler(map: Map<*, *>) {\n    return {\n      /**\n       * Get handler for the Map backed Array Proxy\n       *\n       * @memberof! GQLEnum\n       * @method get\n       *\n       * @param {mixed} obj the object targeted by the Proxy\n       * @param {string} key `key` of the value being requested\n       * @return {mixed} the `value` being requested\n       */\n      get(obj, key) {\n        if (map.has(key)) {\n          return map.get(key)\n        }\n\n        return obj[key]\n      },\n\n      /**\n       * Set handler for the Map backed Array Proxy.\n       *\n       * @memberof! GQLEnum\n       * @method set\n       *\n       * @param {mixed} obj the object the Proxy is targeting\n       * @param {string} key a string `key` being set\n       * @param {mixed} value the `value` being assigned to `key`\n       */\n      set(obj, key, value) {\n        if (isFinite(key) && value instanceof Symbol) {\n          map.set(value.name, value)\n          map.set(value.value, value)\n        }\n\n        // Some accessor on the receiving array\n        obj[key] = value;\n\n        // Arrays return length when pushing. Assume value as return\n        // otherwise. ¯\\_(ツ)_/¯\n        return isFinite(key) ? obj.length : obj[key];\n      }\n    }\n  }\n\n  /** @inheritdoc */\n  static apiDocs(): Object {\n    const { DOC_CLASS, DOC_FIELDS, joinLines } = this;\n\n    return {\n      [DOC_CLASS]: joinLines`\n        GQLEnums allow the definition of enum types with description fields\n        and values other than a 1:1 mapping of their types and their type\n        names. If you are reading this, the implementor likely did not\n        contribute comments for their type.\n      `\n    }\n  }\n}\n"]}