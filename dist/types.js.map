{"version":3,"sources":["../es6/types.js"],"names":["typeOf","isNativeClassByProps","isNativeClassByString","extendsFrom","object","exec","Object","prototype","toString","call","isFunction","obj","Function","name","isArray","Array","isDate","Date","isObject","isString","String","isNumber","isRegExp","RegExp","isNull","NULL","isUndefined","UNDEFINED","isPrimitive","PRIMITIVES","has","isValue","isOfType","T","isClass","thing","hasOwnProperty","value","indexOf","TestedClass","RootClass","enforceClasses","constructor","ParentClass","parseInt","process","version","substring","Error","undefined","Boolean","Number","bind","o"],"mappings":"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","file":"types.js","sourceRoot":"es6","sourcesContent":["/** @namespace types */\n/** @flow */\n\n/**\n * One common way to determine the type of class that you are working with, \n * in a fairly compatible manner, is to use .call or .apply on the function \n * toString of the Object.prototype.\n *\n * Calling `Object.prototype.toString.call('hello')` will yield \n * `\"[object String]\"` as an answer. This technique is fairly sound but is \n * also fairly verbose to use often. This function extracts the detected value \n * name from the above string; so \"String\" from \"[object String]\" and so forth. \n *\n * The added advantage of using this method is that it works well with direct \n * name comparisons, such as `typeOf(\"asdfas\") === String.name`. The new \n * `Symbol.toStringTag` allows you to define custom values that are \n * reflected in this manner.\n * \n * @method ⌾⠀typeOf\n * @memberof types\n * @inner\n * \n * @param {mixed} object any value is acceptable here, including null and \n * undefined\n * @return {string} for objects of type [object String] the value \"String\"\n * will be returned.\n */\nexport function typeOf(object: mixed): string { \n  return /(\\b\\w+\\b)\\]/.exec(Object.prototype.toString.call(object))[1];\n}\n\n/**\n * Returns true if the type supplied evaluates to `[object Function]`\n * \n * @method ⌾⠀isFunction \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isFunction = (obj: mixed) => typeOf(obj) === Function.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Array]`\n * \n * @method ⌾⠀isArray \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isArray = (obj: mixed) => typeOf(obj) === Array.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Date]`\n * \n * @method ⌾⠀isDate \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isDate = (obj: mixed) => typeOf(obj) === Date.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Object]`\n * \n * @method ⌾⠀isObject \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isObject = (obj: mixed) => typeOf(obj) === Object.name\n\n/**\n * Returns true if the type supplied evaluates to `[object String]`\n * \n * @method ⌾⠀isString \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isString = (obj: mixed) => typeOf(obj) === String.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Number]`\n * \n * @method ⌾⠀isNumber \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isNumber = (obj: mixed) => typeOf(obj) === isNumber.name\n\n/**\n * Returns true if the type supplied evaluates to `[object RegExp]`\n * \n * @method ⌾⠀isRegExp \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isRegExp = (obj: mixed) => typeOf(obj) === RegExp.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Null]`\n * \n * @method ⌾⠀isNull \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isNull = (obj: mixed) => typeOf(obj) === NULL\n\n/**\n * Returns true if the type supplied evaluates to `[object Undefined]`\n * \n * @method ⌾⠀isUndefined \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isUndefined = (obj: mixed) => typeOf(obj) === UNDEFINED\n\n/**\n * Determines if the resulting type is one of the six types of primitives\n * (according to MDN; https://goo.gl/USmkUU). If it is, true will be returned;\n * otherwise false.\n *\n * @method ⌾⠀isPrimitive\n * @memberof types\n * @inner\n *\n * @param {mixed} obj given any value, it will return true if it is a primitive \n * @return {Boolean} true if not one of Boolean, Null, Undefined, Number, \n * String or Symbol. \n */\n// $ComputedType\nexport const isPrimitive = (obj: mixed) => PRIMITIVES.has(obj) \n\n/**\n * Returns true if the type supplied evaluates to neither `[object Object]`\n * nor `[object Array]`. \n * \n * @method ⌾⠀isValue \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isValue = (obj: mixed) => (!isObject(obj) && !isArray(obj))\n\n/**\n * A shorthand way to test an object's declared toString type to a supplied \n * string or Function/Class. Realistically, this checks typeOf(obj) to both \n * T and T.name. If either are true, then true is returned; false otherwise.\n * \n * @method ⌾⠀isOfType \n * @memberof types\n * @inner\n * \n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @param {Function} T the type you wish to test for. Ideally this should be \n * a class/function \n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isOfType = (\n  obj: mixed, \n  T: Function\n) => (typeOf(obj) === T || typeOf(obj) === T.name)\n\n/**\n * Returns true if the supplied obj is a ECMAScript class definition. It first \n * checks by examining the properties of the supplied class. Secondly it checks \n * by searching the toString() method of the 'function' for the term class. If \n * either are true, then true is returned; false is returned otherwise.\n *\n * NOTE Relying on this strictly, especially when used with other libraries\n * can cause some problems down the line, especially if the code wraps a class \n * instance like react-jss or other similar use cases. Use at your own peril.\n *\n * @method ⌾⠀isClass\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object who's type is to be compared as a class\n * @return {boolean} true if the obj is an ECMAScript class object; not an \n * instance. False otherwise. \n *\n * @see #isNativeClassByProps\n * @see #isNativeClassByString\n */\nexport const isClass = (obj: mixed) => (\n  isNativeClassByProps(obj) || \n  isNativeClassByString(obj))\n   \n/**\n * isNativeClass method taken from code submitted on stackoverflow. Logic and \n * basis for the test appears there. See URL below for follow up if desired.\n *\n * @see  https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function#32235645\n * \n * @method ⌾⠀isNativeClassByProps\n * @memberof types\n * @inner\n * \n * @param {mixed} thing any type of JavaScript value to test\n * @return {boolean} true if it is a ECMAScript class by testing properties;\n * false otherwise\n */\nexport function isNativeClassByProps(thing: mixed): boolean {\n  return (\n    typeof thing === 'function' \n    && thing.hasOwnProperty('prototype') \n    && !thing.hasOwnProperty('arguments'))\n}\n\n/**\n * isNativeClass method taken from code submitted on stackoverflow. Logic and \n * basis for the test appears there. See URL below for follow up if desired.\n *\n * @see  https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function#32235645\n * \n * @method ⌾⠀isNativeClassByString\n * @memberof types\n * @inner\n * \n * @param {mixed} thing any type of JavaScript value to test\n * @return {Boolean} true if it is a ECMAScript class by testing properties;\n * false otherwise\n */\nexport function isNativeClassByString(value: mixed):boolean {\n  return (\n    typeof value === 'function' \n    && value.toString().indexOf('class') === 0)\n}\n\n/**\n * NOTE This function will not work on nodejs versions less than 6 as Reflect \n * is needed natively.\n * \n * The instanceof keyword only works on instances of an object and not on \n * the class objects the instances are created from.\n *\n * ```js\n * class A {}\n * class B extends A {}\n *\n * let a = new A();\n * let b = new B();\n *\n * b instanceof A; // true\n * a instanceof A; // true\n * B instanceof A; // false\n * ```\n *\n * Therefore the extendsFrom function checks this relationship at the class \n * level and not at the instance level.\n *\n * ```js\n * import { extendsFrom } from '...'\n * \n * class A {}\n * class B extends A {}\n * class C extends B {}\n *\n * extendsFrom(A, A); // true\n * extendsFrom(B, A); // true\n * extendsFrom(C, A); // true\n * extendsFrom(C, 1); // false\n * extendsFrom(B, null); // false\n * ```\n * \n * @method ⌾⠀extendsFrom\n * @memberof types\n * @inner\n * \n * @param {Function} TestedClass the class of which to test heredity \n * @param {Function} RootClass the ancestor to test for\n * @param {Boolean} enforceClasses if true, false by default, an additional \n * runtime check for the type of the supplied Class objects will be made. If \n * either is not a Function, an error is thrown. \n * @return {Boolean} true if the lineage exists; false otherwise \n *\n * @see types#isClass \n */\nexport function extendsFrom(\n TestedClass: Function, \n RootClass: Function,\n enforceClasses: boolean = false\n): boolean {\n  if (!TestedClass || !RootClass) {\n    return false;\n  }\n\n  if (TestedClass === RootClass) {\n    return true;\n  }\n\n  TestedClass = TestedClass.constructor && typeof TestedClass !== 'function'\n    ? TestedClass.constructor : TestedClass\n\n  RootClass = RootClass.constructor && typeof RootClass !== 'function'\n    ? RootClass.constructor : RootClass\n\n  let ParentClass = TestedClass;\n  \n  if (parseInt(process.version.substring(1)) < 6) {\n    throw new Error(`\n      Reflect must be implemented in the JavaScript engine. This cannot be\n      polyfilled and as such, if process.version is less than 6 an error will\n      be thrown. Please try an alternate means of doing what you desire.\n    `);\n  }\n  \n  if (enforceClasses) {\n    if (!isClass(TestedClass) && !isClass(RootClass)) {\n      throw new Error(`\n        When using extendsFrom() with enforceClasses true, each Function \n        argument supplied must pass the isClass() method testing. See the \n        function isClass to learn more about these requirements.\n      `);\n    }\n  }\n    \n  if (!TestedClass || !RootClass) { return false; }\n  if (TestedClass === RootClass) { return true; }\n  \n  do { \n    ParentClass = Reflect.getPrototypeOf(ParentClass);\n    \n    if (ParentClass === RootClass) {\n      return true;\n    }\n  }\n  while (ParentClass);\n  \n  return false;\n}\n\n/**\n * Programmatic constant defintion of the result of a call to \n * `typeOf(undefined)`.\n *\n * @memberof types\n * @type {string}\n * @const \n */\nexport const UNDEFINED: string = typeOf(undefined);\n\n/**\n * Programmatic constant defintion of the result of a call to \n * `typeOf(null)`.\n *\n * @memberof types\n * @type {string}\n * @const \n */\nexport const NULL: string = typeOf(null);\n\n/**\n * Create a base set containing the typeOf representations for each of the \n * known primitive types. \n *\n * @type {Set<String>}\n * @memberof types \n * @inner \n */\nconst PRIMITIVES: Set<string> = new Set([\n  NULL, UNDEFINED, Boolean.name, Number.name, String.name, Symbol.name\n]);\n\n/** Store the original has() method and bind it to PRIMITIVES; $ComputedType */\nPRIMITIVES[Symbol.for('original_has')] = PRIMITIVES.has.bind(PRIMITIVES)\n\n/**\n * Modify the PRIMITIVES `has()` method to invoke `typeOf()` on the argument \n * before passing it to the underlying has() method originally passed down from \n * the Set.prototype. \n * \n * @method has\n * @memberof PRIMITIVES\n * @inner\n * \n * @param {mixed} o any value to test to see if it qualifies as a primitive\n * @return {Boolean} true if the supplied value is a primitive, false otherwise\n */\n// $ComputedType\nPRIMITIVES.has = (o: mixed) => PRIMITIVES[Symbol.for('original_has')](typeOf(o))\n\n/**\n * When testing if a type is a primitive, it is often easier to simply verify \n * that with a list of known types. To make this dead simple, a modified `Set`\n * containing the `typeOf` results for each of the six known JavaScript \n * primitive types is exported.\n *\n * The modifications are such that a call to `has()`, on this Set only, first \n * converts the supplied values to their resulting `typeOf()` representations.\n * So, `PRIMITIVES.has(4)` would be the same as `PRIMITIVES.has('Number')`.\n *\n * @memberof types\n * @type {Set<string>}\n * @const \n */\nexport { PRIMITIVES };"]}