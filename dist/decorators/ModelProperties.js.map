{"version":3,"sources":["../../es6/decorators/ModelProperties.js"],"names":["DirectTypeAdd","applyTags","Getters","Setters","Properties","extractBits","property","array","reply","error","Error","depth","fieldName","modelName","typeClass","getterMaker","setterMaker","v","undefined","length","thisClass","constructor","model","MODEL_KEY","val","GQLBase","console","name","SCHEMA","results","SyntaxTree","findField","meta","args","requestData","nullable","type","DIRECT_TYPES","includes","GQL_TYPE","GraphQLEnumType","value","String","DirectTypeManager","types","add","className","push","clear","splice","reset","target","Class","addTags","descriptor","tags","Array","isArray","map","tag","filter","forEach","META_KEY","propertyNames","desc","prototype","hasImpl","get","GETTERS","concat","warn","SETTERS","set","PROPS"],"mappings":"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","file":"ModelProperties.js","sourceRoot":"es6","sourcesContent":["/** @namespace decorators */\n\nimport {\n  GQLBase, MODEL_KEY, META_KEY, GETTERS, SETTERS, PROPS, AUTO_PROPS\n} from '../GQLBase'\nimport { isArray, extendsFrom } from 'ne-types'\nimport { inspect } from 'util'\nimport { GraphQLEnumType, parse } from 'graphql'\nimport { SyntaxTree } from '../SyntaxTree'\n\n/**\n * For each of the decorators, Getters, Setters, and Properties, we take a\n * list of property names used to create the appropriate accessor types. In\n * some cases, however, the instance of GQLBase's data model may have a\n * different name. Finally if the return type for the getter should be wrapped\n * in a another GQLBase class type, we will need a way to specify those things\n * too.\n *\n * The `extractBits()` takes a single argument value from the decorator as it\n * parses them and converts it into an object, properly sorted, into values that\n * allow the above described behavior.\n *\n * Examples:\n *\n * ```\n * // Create a class with a name and age property that map directly to the\n * // underlying data model\n * @Getters('name', 'age')\n * class MyType extends GQLBase {...}\n *\n * // Create a class with a name property that maps to a different property\n * // name in the underlying data model\n * @Getters(['name', '_fake_name'])\n * class MyMockType extends GQLBase {...}\n *\n * // Create a class with an employee property that returns an Employee\n * @Getters(['employee', Employee])\n * class MyRoleType extends GQLBase {...}\n *\n * // Finally create a class with an employe property that returns an Employee\n * // with data under a different name in the underlying data model.\n * @Getters(['employee', '_worker', Employee])\n * class MyMockRoleType extends GQLBase {...}\n * ```\n *\n * @memberof decorators\n * @method ‚åæ‚†ÄextractBits\n * @since 2.5\n *\n * @param {String|Array<String|Function>} property name of a property, or list\n * of property names and a Class.\n * @return {Object} an object with the following format ```\n * {\n *   fieldName: name of root instance property to create\n *   modelName: name of its associated internal model property\n *   typeClass: an optional class to wrap around the results in a getter\n * }\n * ```\n */\nfunction extractBits(property) {\n  let array = isArray(property) ? property : [property, property, null]\n  let reply;\n\n  if (!property) {\n    let error = new Error(\n      'Invalid property. Given\\n  %o',\n      inspect(property, {depth: 2})\n    );\n\n    return {\n      fieldName: 'anErrorOccurred',\n      modelName: 'anErrorOccurred',\n      typeClass: null,\n      getterMaker: function() { return () => error },\n      setterMaker: function() { return (v) => undefined }\n    }\n  }\n\n  //\n  if (array.length === 3) {\n    reply = {\n      fieldName: array[0],\n      modelName: array[1],\n      typeClass: typeof array[2] === 'function' && array[2] || null\n    }\n  }\n\n  //\n  else if (array.length === 2) {\n    reply = {\n      fieldName: array[0],\n      modelName: typeof array[1] === 'string'\n        ? array[1]\n        : array[0],\n      typeClass: typeof array[1] === 'function' && array[1] || null\n    }\n  }\n\n  //\n  else {\n    reply = {\n      fieldName: array[0],\n      modelName: array[0],\n      typeClass: array[0]\n    }\n  }\n\n  reply.getterMaker = function() {\n    let { modelName, fieldName, typeClass } = reply;\n\n    return function() {\n      const thisClass = this.constructor\n      const model = this[MODEL_KEY] || null\n      let val\n\n      if (!extendsFrom(thisClass, GQLBase)) {\n        console.error(`${thisClass.name} is not derived from GQLBase`);\n        return undefined\n      }\n\n      if (!thisClass.SCHEMA) {\n        throw new Error(`\n        All GQLBase extended classes should have a defined SCHEMA. Please\n        manually define a static get SCHEMA() in your class or use the\n        @Schema() decorator to do so.\n        `)\n      }\n\n      if (typeClass) {\n        // If the value of the model is already the type of class we expect\n        // we do not need to do any processing and we can just grab it and\n        // go.\n        if (model[modelName] && extendsFrom(model[modelName], typeClass)) {\n          val = model[modelName]\n        }\n\n        // Otherwise we need to return an instance of the determined typeClass\n        // and pass that back instead; as requested.\n        else {\n          const results = SyntaxTree.findField(\n            parse(this.constructor.SCHEMA),\n            this.constructor.name,\n            modelName\n          )\n          const { meta } = results || { meta: null };\n\n          let args = [model[modelName], this.requestData];\n\n          if (meta && !meta.nullable && !model) {\n            throw new Error(`\n              Using @Getters or @Properties decorators with a null or\n              undefined model when the schema states that this field\n              cannot be null.\n\n              Type      : ${typeClass.name}\n              Field (AST data)\n                name    : ${meta.name}\n                type    : ${meta.type}\n                nullable: ${meta.nullable}\n              [getter]  : ${fieldName}\n              [maps to] : ${modelName}\n              [model  ] : ${model}\n            `)\n          }\n\n          // If the following is true, it means that despite allowing nulls\n          // for this field in the schema, we do have a valid model and should\n          // proceed.\n          if (model) {\n            if (extractBits.DIRECT_TYPES.includes(typeClass.name)) {\n              val = typeClass(...args)\n            }\n            else {\n              val = new typeClass(...args)\n            }\n\n            if (typeClass.GQL_TYPE === GraphQLEnumType) { return val.value; }\n          }\n        }\n      }\n      else {\n        val = model[modelName];\n      }\n\n      if (val === 'undefined' || val === undefined) {\n        val = null;\n      }\n\n      return val;\n    }\n  }\n\n  reply.setterMaker = function() {\n    let { modelName } = reply;\n    return function (value) {\n      this[MODEL_KEY][modelName] = value;\n    }\n  }\n\n  return reply;\n}\n\n/**\n * An array of proper class names that are used to test for cases where the\n * proper usage of instantiating an instance should preclude the use of `new`\n *\n * @memberof decorators\n * @type {Array<String>}\n */\nextractBits.DIRECT_TYPES = [\n  String.name\n];\n\n/**\n * A small suite of functions a getter that allows easy manipulation of the\n * the DIRECT_TYPES workaround needed for some types of complex class\n * wrapping allowed by the @Getters and @Properties decorators. Namely the\n * ability to do something like @Getters('name', String) which would wrap the\n * contents of whatever is in the objects model in a String call.\n *\n * Direct types are those that need to be called without `new` in order for the\n * desired behavior to present itself.\n *\n * @memberof decorators\n * @type {Object}\n * @since 2.7.0\n */\nexport const DirectTypeManager = {\n  /**\n   * A getter that retrieves the array of direct types\n   *\n   * @method DirectTypeManager#types\n   * @member {Array<String>} types\n   *\n   * @return {Array<String>} an array of class name strings.\n   */\n  get types(): Array<String> {\n    return extractBits.DIRECT_TYPES\n  },\n\n  /**\n   * Appends the supplied class name to the list of registered direct types. If\n   * a class or function is passed, rather than a String,\n   *\n   * @method DirectTypeManager#types\n   *\n   * @param {Function|string|RegExp} className the name of the class to append.\n   * Typically it is best to pass the name property of the class in question\n   * such as `RegExp.name` or `MyClass.name`.\n   */\n  add(className: string | RegExp | Function): void {\n    if (typeof className === 'function') {\n      className = className.name\n    }\n\n    extractBits.DIRECT_TYPES.push(className);\n  },\n\n  /**\n   * Foricbly empties the contents of the extractBits.DIRECT_TYPES array. This\n   * is not recommended as it can have unintended consequences. It is\n   * recommended to use `reset` instead\n   *\n   * @method DirectTypeManager#clear\n   *\n   * @return {Array<string>} an array of class name Strings that were removed\n   * when cleared.\n   */\n  clear(): Array<string> {\n    return extractBits.DIRECT_TYPES.splice(0, extractBits.DIRECT_TYPES.length)\n  },\n\n  /**\n   * The recommended way to reset the DIRECT_TYPES list. This removes all\n   * changed values, returns the removed bits, and adds back in the defaults.\n   *\n   * @method DirectTypeManager#reset\n   *\n   * @return {Array<string>} an array of class name Strings that were removed\n   * during the reset process.\n   */\n  reset(): Array<string> {\n    return extractBits.DIRECT_TYPES.splice(\n      0,\n      extractBits.DIRECT_TYPES.length,\n      String.name\n    )\n  }\n}\n\n/**\n * This decorator allows you to add a Class method to the DirectTypeManager\n * as a function that should not be invoked with the `new` keyword. For all\n * intents and purposes the function should be declared `static`.\n *\n * @method DirectTypeAdd\n * @param {Function} target [description]\n * @constructor\n */\nexport function DirectTypeAdd(target) {\n  DirectTypeManager.add(target);\n  return target;\n}\n\n/**\n * When applying multiple property getters and setters, knowing some info\n * about what was applied elsewhere can be important. \"Tags\" can be applied\n * that store the fieldName and descriptor applied via one of these decorators.\n *\n * Multiple \"tags\" are supported to allow for detecting the difference between\n * decorators applied by the developer using lattice and something auto\n * generated such as auto-props.\n *\n * @param  {GQLBase} Class an instance of GQLBase to apply the tags tp\n * @param  {Array<string|Symbol>} addTags an array of Symbols or strings to be\n * wrapped in Symbols that will be used as tag keys\n * @param  {string} fieldName the name of the field being decorated\n * @param  {Object} descriptor the JavaScript descriptor object to associate\n * with this tagged field.\n */\nexport function applyTags(\n  Class:GQLBase,\n  addTags: Array<string|Symbol>,\n  fieldName: string,\n  descriptor: Object\n) {\n  let tags = (Array.isArray(addTags) && addTags || [])\n    .map(tag => typeof tag === 'string' && Symbol.for(tag) || tag)\n    .filter(tag => typeof tag === 'symbol')\n\n  tags.forEach(tag => {\n    Class[META_KEY][tag] = Class[META_KEY][tag] || {}\n    Class[META_KEY][tag][fieldName] = descriptor\n  })\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the getters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which getters should be injected.\n *\n * @function üè∑‚†ÄGetters\n * @memberof! decorators\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has 'name'\n * and 'age' as properties, then passing those two strings will result\n * in getters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method.s\n */\nexport function Getters(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed, addTags: Array<string|Symbol> = []): mixed {\n    for (let property of propertyNames) {\n      let { fieldName, getterMaker } = extractBits(property);\n      let desc = Object.getOwnPropertyDescriptor(target.prototype, fieldName)\n      let hasImpl = desc && (desc.get || typeof desc.value === 'function')\n      let tags = [GETTERS].concat(Array.isArray(addTags) && addTags || [])\n\n      if (!hasImpl) {\n        let descriptor = {\n          get: getterMaker()\n        }\n\n        applyTags(target, tags, fieldName, descriptor)\n        Object.defineProperty(target.prototype, fieldName, descriptor);\n      }\n      else {\n        console.warn(\n          `Skipping getter for ${target.name}.${fieldName}; already exists`\n        )\n      }\n    }\n\n    return target;\n  }\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the setters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which setters should be injected.\n *\n * @function üè∑‚†ÄSetters\n * @memberof! decorators\n * @since 2.1.0\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has\n * 'name' and 'age' as properties, then passing those two strings will\n * result in setters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method\n */\nexport function Setters(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed, addTags: Array<String|Symbol> = []): mixed {\n    for (let property of propertyNames) {\n      let { fieldName, setterMaker } = extractBits(property);\n      let desc = Object.getOwnPropertyDescriptor(target.prototype, fieldName)\n      let hasImpl = desc && (desc.get || typeof desc.value === 'function')\n      let tags = [SETTERS].concat(Array.isArray(addTags) && addTags || [])\n\n      if (!hasImpl) {\n        let descriptor = {\n          set: setterMaker()\n        }\n\n        applyTags(target, tags, fieldName, descriptor)\n        Object.defineProperty(target.prototype, fieldName, descriptor);\n      }\n      else {\n        console.warn(\n          `Skipping setter for ${target.name}.${fieldName}; already exists`\n        )\n      }\n    }\n\n    return target;\n  }\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the getters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which getters should be injected.\n *\n * This method creates both getters and setters\n *\n * @function üè∑‚†ÄProperties\n * @memberof! decorators\n * @since 2.1.0\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has 'name'\n * and 'age' as properties, then passing those two strings will result\n * in getters and setters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method\n */\nexport function Properties(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed, addTags: Array<String|Symbol> = []): mixed {\n    for (let property of propertyNames) {\n      let {fieldName, getterMaker, setterMaker } = extractBits(property);\n      let desc = Object.getOwnPropertyDescriptor(target.prototype, fieldName)\n      let hasImpl = desc && (desc.get || typeof desc.value === 'function')\n      let tags = [PROPS].concat(Array.isArray(addTags) && addTags || [])\n\n      if (!hasImpl) {\n        let descriptor = {\n          set: setterMaker(),\n          get: getterMaker()\n        }\n\n        applyTags(target, tags, fieldName, descriptor)\n        Object.defineProperty(target.prototype, fieldName, descriptor);\n      }\n      else {\n        console.warn(\n          `Skipping properties for ${target.name}.${fieldName}; already exists`\n        )\n      }\n    }\n\n    return target;\n  }\n}\n\nexport default Properties;\n"]}