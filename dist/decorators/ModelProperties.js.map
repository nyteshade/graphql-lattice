{"version":3,"sources":["../../es6/decorators/ModelProperties.js"],"names":["DirectTypeAdd","Getters","Setters","Properties","extractBits","property","array","reply","error","Error","depth","fieldName","modelName","typeClass","getterMaker","setterMaker","v","undefined","length","thisClass","constructor","model","val","console","name","SCHEMA","results","findField","meta","args","requestData","nullable","type","DIRECT_TYPES","includes","GQL_TYPE","value","String","DirectTypeManager","types","add","className","push","clear","splice","reset","target","propertyNames","getters","prototype","get","warn","setters","set","props"],"mappings":"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","file":"ModelProperties.js","sourceRoot":"es6","sourcesContent":["/** @namespace decorators */\n\nimport { GQLBase, MODEL_KEY, META_KEY } from '../GQLBase'\nimport { isArray, extendsFrom } from '../types'\nimport { inspect } from 'util'\nimport { GraphQLEnumType, parse } from 'graphql'\nimport { SyntaxTree } from '../SyntaxTree'\n\n/**\n * For each of the decorators, Getters, Setters, and Properties, we take a\n * list of property names used to create the appropriate accessor types. In\n * some cases, however, the instance of GQLBase's data model may have a\n * different name. Finally if the return type for the getter should be wrapped\n * in a another GQLBase class type, we will need a way to specify those things\n * too.\n *\n * The `extractBits()` takes a single argument value from the decorator as it\n * parses them and converts it into an object, properly sorted, into values that\n * allow the above described behavior.\n *\n * Examples:\n *\n * ```\n * // Create a class with a name and age property that map directly to the\n * // underlying data model\n * @Getters('name', 'age')\n * class MyType extends GQLBase {...}\n *\n * // Create a class with a name property that maps to a different property\n * // name in the underlying data model\n * @Getters(['name', '_fake_name'])\n * class MyMockType extends GQLBase {...}\n *\n * // Create a class with an employee property that returns an Employee\n * @Getters(['employee', Employee])\n * class MyRoleType extends GQLBase {...}\n *\n * // Finally create a class with an employe property that returns an Employee\n * // with data under a different name in the underlying data model.\n * @Getters(['employee', '_worker', Employee])\n * class MyMockRoleType extends GQLBase {...}\n * ```\n *\n * @memberof decorators\n * @method ‚åæ‚†ÄextractBits\n * @since 2.5\n *\n * @param {String|Array<String|Function>} property name of a property, or list\n * of property names and a Class.\n * @return {Object} an object with the following format ```\n * {\n *   fieldName: name of root instance property to create\n *   modelName: name of its associated internal model property\n *   typeClass: an optional class to wrap around the results in a getter\n * }\n * ```\n */\nfunction extractBits(property) {\n  let array = isArray(property) ? property : [property, property, null]\n  let reply;\n\n  if (!property) {\n    let error = new Error(\n      'Invalid property. Given\\n  %o',\n      inspect(property, {depth: 2})\n    );\n\n    return {\n      fieldName: 'anErrorOccurred',\n      modelName: 'anErrorOccurred',\n      typeClass: null,\n      getterMaker: function() { return () => error },\n      setterMaker: function() { return (v) => undefined }\n    }\n  }\n\n  //\n  if (array.length === 3) {\n    reply = {\n      fieldName: array[0],\n      modelName: array[1],\n      typeClass: typeof array[2] === 'function' && array[2] || null\n    }\n  }\n\n  //\n  else if (array.length === 2) {\n    reply = {\n      fieldName: array[0],\n      modelName: typeof array[1] === 'string'\n        ? array[1]\n        : array[0],\n      typeClass: typeof array[1] === 'function' && array[1] || null\n    }\n  }\n\n  //\n  else {\n    reply = {\n      fieldName: array[0],\n      modelName: array[0],\n      typeClass: array[0]\n    }\n  }\n\n  reply.getterMaker = function() {\n    let { modelName, fieldName, typeClass } = reply;\n\n    return function() {\n      const thisClass = this.constructor\n      const model = this[MODEL_KEY] || null\n      let val\n\n      if (!extendsFrom(thisClass, GQLBase)) {\n        console.error(`${thisClass.name} is not derived from GQLBase`);\n        return undefined\n      }\n\n      if (!thisClass.SCHEMA) {\n        throw new Error(`\n        All GQLBase extended classes should have a defined SCHEMA. Please\n        manually define a static get SCHEMA() in your class or use the\n        @Schema() decorator to do so.\n        `)\n      }\n\n      if (typeClass) {\n        // If the value of the model is already the type of class we expect\n        // we do not need to do any processing and we can just grab it and\n        // go.\n        if (extendsFrom(model[modelName], typeClass)) {\n          val = model[modelName]\n        }\n\n        // Otherwise we need to return an instance of the determined typeClass\n        // and pass that back instead; as requested.\n        else {\n          const results = SyntaxTree.findField(\n            parse(this.constructor.SCHEMA),\n            this.constructor.name,\n            modelName\n          )\n          const { meta } = results || { meta: null };\n\n          let args = [model[modelName], this.requestData];\n\n          if (meta && !meta.nullable && !model) {\n            throw new Error(`\n              Using @Getters or @Properties decorators with a null or\n              undefined model when the schema states that this field\n              cannot be null.\n\n              Type      : ${typeClass.name}\n              Field (AST data)\n                name    : ${meta.name}\n                type    : ${meta.type}\n                nullable: ${meta.nullable}\n              [getter]  : ${fieldName}\n              [maps to] : ${modelName}\n              [model  ] : ${model}\n            `)\n          }\n\n          // If the following is true, it means that despite allowing nulls\n          // for this field in the schema, we do have a valid model and should\n          // proceed.\n          if (model) {\n            if (extractBits.DIRECT_TYPES.includes(typeClass.name)) {\n              val = typeClass(...args)\n            }\n            else {\n              val = new typeClass(...args)\n            }\n\n            if (typeClass.GQL_TYPE === GraphQLEnumType) { return val.value; }\n          }\n        }\n      }\n      else {\n        val = model[modelName];\n      }\n\n      if (val === 'undefined' || val === undefined) {\n        val = null;\n      }\n\n      return val;\n    }\n  }\n\n  reply.setterMaker = function() {\n    let { modelName } = reply;\n    return function (value) {\n      this[MODEL_KEY][modelName] = value;\n    }\n  }\n\n  return reply;\n}\n\n/**\n * An array of proper class names that are used to test for cases where the\n * proper usage of instantiating an instance should preclude the use of `new`\n *\n * @memberof decorators\n * @type {Array<String>}\n */\nextractBits.DIRECT_TYPES = [\n  String.name\n];\n\n/**\n * A small suite of functions a getter that allows easy manipulation of the\n * the DIRECT_TYPES workaround needed for some types of complex class\n * wrapping allowed by the @Getters and @Properties decorators. Namely the\n * ability to do something like @Getters('name', String) which would wrap the\n * contents of whatever is in the objects model in a String call.\n *\n * Direct types are those that need to be called without `new` in order for the\n * desired behavior to present itself.\n *\n * @memberof decorators\n * @type {Object}\n * @since 2.7.0\n */\nexport const DirectTypeManager = {\n  /**\n   * A getter that retrieves the array of direct types\n   *\n   * @method DirectTypeManager#types\n   * @member {Array<String>} types\n   *\n   * @return {Array<String>} an array of class name strings.\n   */\n  get types(): Array<String> {\n    return extractBits.DIRECT_TYPES\n  },\n\n  /**\n   * Appends the supplied class name to the list of registered direct types. If\n   * a class or function is passed, rather than a String,\n   *\n   * @method DirectTypeManager#types\n   *\n   * @param {Function|string|RegExp} className the name of the class to append.\n   * Typically it is best to pass the name property of the class in question\n   * such as `RegExp.name` or `MyClass.name`.\n   */\n  add(className: string | RegExp | Function): void {\n    if (typeof className === 'function') {\n      className = className.name\n    }\n\n    extractBits.DIRECT_TYPES.push(className);\n  },\n\n  /**\n   * Foricbly empties the contents of the extractBits.DIRECT_TYPES array. This\n   * is not recommended as it can have unintended consequences. It is\n   * recommended to use `reset` instead\n   *\n   * @method DirectTypeManager#clear\n   *\n   * @return {Array<string>} an array of class name Strings that were removed\n   * when cleared.\n   */\n  clear(): Array<string> {\n    return extractBits.DIRECT_TYPES.splice(0, extractBits.DIRECT_TYPES.length)\n  },\n\n  /**\n   * The recommended way to reset the DIRECT_TYPES list. This removes all\n   * changed values, returns the removed bits, and adds back in the defaults.\n   *\n   * @method DirectTypeManager#reset\n   *\n   * @return {Array<string>} an array of class name Strings that were removed\n   * during the reset process.\n   */\n  reset(): Array<string> {\n    return extractBits.DIRECT_TYPES.splice(\n      0,\n      extractBits.DIRECT_TYPES.length,\n      String.name\n    )\n  }\n}\n\n/**\n * This decorator allows you to add a Class method to the DirectTypeManager\n * as a function that should not be invoked with the `new` keyword. For all\n * intents and purposes the function should be declared `static`.\n *\n * @method DirectTypeAdd\n * @param {Function} target [description]\n * @constructor\n */\nexport function DirectTypeAdd(target) {\n  DirectTypeManager.add(target);\n  return target;\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the getters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which getters should be injected.\n *\n * @function üè∑‚†ÄGetters\n * @memberof! decorators\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has 'name'\n * and 'age' as properties, then passing those two strings will result\n * in getters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method.s\n */\nexport function Getters(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed): mixed {\n    for (let property of propertyNames) {\n      let { fieldName, getterMaker } = extractBits(property);\n\n      if (!target[META_KEY].getters) {\n        target[META_KEY].getters = []\n      }\n      target[META_KEY].getters.push(fieldName)\n\n      if (typeof target.prototype[fieldName] === 'undefined') {\n        Object.defineProperty(target.prototype, fieldName, {\n          get: getterMaker()\n        });\n      }\n      else {\n        console.warn(`Skipping the getter for ${target.name}.${fieldName}`)\n      }\n    }\n\n    return target;\n  }\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the setters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which setters should be injected.\n *\n * @function üè∑‚†ÄSetters\n * @memberof! decorators\n * @since 2.1.0\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has\n * 'name' and 'age' as properties, then passing those two strings will\n * result in setters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method\n */\nexport function Setters(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed): mixed {\n    for (let property of propertyNames) {\n      let { fieldName, setterMaker } = extractBits(property);\n\n      if (!target[META_KEY].setters) {\n        target[META_KEY].setters = []\n      }\n      target[META_KEY].setters.push(fieldName)\n\n      if (typeof target.prototype[fieldName] === 'undefined') {\n        Object.defineProperty(target.prototype, fieldName, {\n          set: setterMaker()\n        });\n      }\n      else {\n        console.warn(`Skipping the setter for ${target.name}.${fieldName}`)\n      }\n    }\n\n    return target;\n  }\n}\n\n/**\n * When working with `GQLBase` instances that expose properties\n * that have a 1:1 mapping to their own model property of the\n * same name, adding the getters manually can be annoying. This\n * takes an indeterminate amount of strings representing the\n * properties for which getters should be injected.\n *\n * This method creates both getters and setters\n *\n * @function üè∑‚†ÄProperties\n * @memberof! decorators\n * @since 2.1.0\n *\n * @param {Array<String|Array<String>>} propertyNames if the model has 'name'\n * and 'age' as properties, then passing those two strings will result\n * in getters and setters that surface those properties as GraphQL fields.\n * @return {Function} a class decorator method\n */\nexport function Properties(\n  ...propertyNames: Array<String|Array<String|Function>>\n): Function {\n  return function(target: mixed): mixed {\n    for (let property of propertyNames) {\n      let {\n        fieldName,\n        getterMaker,\n        setterMaker\n      } = extractBits(property);\n\n      if (!target[META_KEY].props) {\n        target[META_KEY].props = []\n      }\n      target[META_KEY].props.push(fieldName)\n\n      if (typeof target.prototype[fieldName] === 'undefined') {\n        Object.defineProperty(target.prototype, fieldName, {\n          set: setterMaker(),\n          get: getterMaker()\n        });\n      }\n      else {\n        console.warn(`Skipping the properties for ${target.name}.${fieldName}`)\n      }\n    }\n\n    return target;\n  }\n}\n\nexport default Properties;\n"]}