{"version":3,"sources":["../../es6/decorators/FileSchema.js"],"names":["FileSchema","path","extension","target","SCHEMA","get","GQLBase","IDLFilePath"],"mappings":";;;;;;;;;;;;;;;kBA0BwBA,U;;AAvBxB;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBe,SAASA,UAAT,CACbC,IADa,EAEbC,YAAoB,UAFP,EAGN;AACP,SAAO,UAASC,MAAT,EAAiC;AACtC;AACA;AACA;AACA,WAAOA,OAAOC,MAAd;;AAEA;AACA,WAAO,gCAAwBD,MAAxB,EAAgC;AACrCC,cAAQ;AACNC,aAAK,MAAMC,iBAAQC,WAAR,CAAoBN,IAApB,EAA0BC,SAA1B;AADL,OAD6B;;AAKrC,OAAC,mBAAW,aAAX,CAAD,GAA6B;AAC3BG,aAAK,MAAM;AADgB;AALQ,KAAhC,CAAP;AASD,GAhBD;AAiBD,C,CA/CD;;;QAiDSL,U,GAAAA,U","file":"FileSchema.js","sourceRoot":"es6","sourcesContent":["/** @namespace decorators */\n// @flow\n\nimport { GQLBase } from '../GQLBase'\n\n/**\n * A decorator that does three things. First it defines the\n * module() static method that is required when using adjacent\n * schema files. Secondly, it defines a SCHEMA getter that\n * returns `GQLBase.ADJACENT_FILE`. Finally it sets a static\n * getter with the `Symbol`, `@adjacentSchema` so that other\n * can determine whether or not the decorator was used.\n *\n * @function ðŸ·â €FileSchema\n * @memberof! decorators\n * @since 2.3.0\n *\n * @param {String} path a relative or absolute path to the file containing\n * your GraphQL IDL schema portion for your object type.\n * @param {String} extension the extension of the graphql schema file pointed\n * to in the previous parameter. By default these are `\".graphql\"` but should\n * your path point to a file with a different extension, you should specify\n * that extension here.\n * @return {mixed} as per all class decorators, `FileSchema` returns the\n * class object being modified\n */\nexport default function FileSchema(\n  path: string,\n  extension: string = \".graphql\"\n): mixed {\n  return function(target: Object): Object {\n    // Attempt to remove the SCHEMA property or function from the class\n    // being decorated. This is not guaranteed to work but should increase\n    // compatibilty and success rates.\n    delete target.SCHEMA;\n\n    // @ComputedType\n    return Object.defineProperties(target, {\n      SCHEMA: {\n        get: () => GQLBase.IDLFilePath(path, extension)\n      },\n\n      [Symbol.for('@fileSchema')]: {\n        get: () => true\n      }\n    });\n  }\n}\n\nexport { FileSchema };\n"]}