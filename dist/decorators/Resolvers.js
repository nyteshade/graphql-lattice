"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mutator = mutator;
exports.resolver = resolver;
exports.subscriptor = subscriptor;

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _GQLBase = require("../GQLBase");

var _neTagFns = require("ne-tag-fns");

var _templateObject, _templateObject2;

/**
 * Since the bulk functionality of @subscriptor, @mutator and
 * @resolver are almost identical, a single function can serve
 * the bulk of the functionality needed since they are so similar
 * in nature.
 *
 * @method decorators~decorate
 * @param {string} metaProperty the name of the meta sub key under which to
 * store the modified decorated function.
 * @param {Object|Function} target either the Class itself, if defined
 * on a static method, or the prototype if defined on an instance method
 * @param {string} key the property name of the function being decorated
 * @param {Object} descriptor a decorator descriptor; see
 * `Object.defineProperty` for more information on descriptors
 */
function decorate(metaProperty, target, key, descriptor) {
  var Class = typeof target === 'function' ? target : target.constructor;
  var proto = typeof target === 'function' ? target.prototype : target;
  var isClass = Class === target;
  var fn = descriptor.value;

  if (!Class instanceof _GQLBase.GQLBase) {
    console.warn((0, _neTagFns.dedent)(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n      Ignoring the transformation of @resolver for ", ".\n      The reason for this is that ", " is not an instance of GQLBase.\n    "])), fn && fn.name || key, Class.name));
    return descriptor;
  }

  if (!descriptor.value || descriptor.get || descriptor.set || descriptor.initializer) {
    console.warn((0, _neTagFns.dedent)(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\n      Ignoring the transformation of @resolver for ", ". The\n      reason for this is that it should only be applied to a static or instance\n      method of a class. It is not valid to apply this to a getter, setter,\n      or property.\n    "])), fn && fn.name || key));
    return descriptor;
  } // Remove the function from wherever it happens to be defined.


  delete target[key];
  delete descriptor.value;

  if (isClass) {
    delete proto[key];
  } else {
    delete Class[key];
  } // Obtain a reference to the metadata storage area and create the resolver
  // portion if it does not yet exist.


  Class[_GQLBase.META_KEY][metaProperty] = Class[_GQLBase.META_KEY][metaProperty] || []; // Ensure that the function name matches the key, if not, wrap it
  // such that future uses of the .name property match the key of the
  // decorated function

  if (fn.name !== key) {
    Object.defineProperty(fn, 'name', {
      get: function get() {
        return key;
      }
    });
  } // Store the key by name, overwritting if necessary, and assign the function


  Class[_GQLBase.META_KEY][metaProperty].push(fn); // Pass the decorated function along for others to consume


  descriptor[Symbol["for"](metaProperty)] = fn; // Return a new decorator descriptor without the value function

  return descriptor;
}
/**
 * The resolver function should perform the necessary insertion to place
 * the decorated function in question into a place that it can be merged
 * with the final list of query resolvers. Typically a resolver function,
 * as defined in `RESOLVERS()` receives a `requestData` object. Functions
 * decorated with `@resolver` receive this as their first parameter. Code
 * accordingly.
 *
 * @method üè∑‚†Ädecorators~resolver
 * @param {Object|Function} target either the Class itself, if defined
 * on a static method, or the prototype if defined on an instance method
 * @param {string} key the property name of the function being decorated
 * @param {Object} descriptor a decorator descriptor; see
 * `Object.defineProperty` for more information on descriptors
 */


function resolver(target, key, descriptor) {
  return decorate('resolvers', target, key, descriptor);
}
/**
 * The mutator function should perform the necessary insertion to place
 * the decorated function in question into a place that it can be merged
 * with the final list of query resolvers. Typically a mutator function,
 * as defined in `RESOLVERS()` receives a `requestData` object. Functions
 * decorated with `@mutator` receive this as their first parameter. Code
 * accordingly.
 *
 * @method üè∑‚†Ädecorators~mutator
 * @param {Object|Function} target either the Class itself, if defined
 * on a static method, or the prototype if defined on an instance method
 * @param {string} key the property name of the function being decorated
 * @param {Object} descriptor a decorator descriptor; see
 * `Object.defineProperty` for more information on descriptors
 */


function mutator(target, key, descriptor) {
  return decorate('mutators', target, key, descriptor);
}
/**
 * The subscriptor function should perform the necessary insertion to place
 * the decorated function in question into a place that it can be merged
 * with the final list of query resolvers. Typically a subscriptor function,
 * as defined in `RESOLVERS()` receives a `requestData` object. Functions
 * decorated with `@subscriptor` receive this as their first parameter.
 * Code accordingly.
 *
 * @method üè∑‚†Ädecorators~subscriptor
 * @param {Object|Function} target either the Class itself, if defined
 * on a static method, or the prototype if defined on an instance method
 * @param {string} key the property name of the function being decorated
 * @param {Object} descriptor a decorator descriptor; see
 * `Object.defineProperty` for more information on descriptors
 */


function subscriptor(target, key, descriptor) {
  return decorate('subscriptors', target, key, descriptor);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9kZWNvcmF0b3JzL1Jlc29sdmVycy5qcyJdLCJuYW1lcyI6WyJkZWNvcmF0ZSIsIm1ldGFQcm9wZXJ0eSIsInRhcmdldCIsImtleSIsImRlc2NyaXB0b3IiLCJDbGFzcyIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJwcm90b3R5cGUiLCJpc0NsYXNzIiwiZm4iLCJ2YWx1ZSIsIkdRTEJhc2UiLCJjb25zb2xlIiwid2FybiIsImRlZGVudCIsIm5hbWUiLCJnZXQiLCJzZXQiLCJpbml0aWFsaXplciIsIk1FVEFfS0VZIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJwdXNoIiwiU3ltYm9sIiwicmVzb2x2ZXIiLCJtdXRhdG9yIiwic3Vic2NyaXB0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLFFBQVQsQ0FDRUMsWUFERixFQUVFQyxNQUZGLEVBR0VDLEdBSEYsRUFJRUMsVUFKRixFQUtVO0FBQ1IsTUFBTUMsS0FBSyxHQUFHLE9BQU9ILE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDQSxNQUFNLENBQUNJLFdBQTdEO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLE9BQU9MLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQU0sQ0FBQ00sU0FBdEMsR0FBa0ROLE1BQWhFO0FBQ0EsTUFBTU8sT0FBTyxHQUFHSixLQUFLLEtBQUtILE1BQTFCO0FBQ0EsTUFBSVEsRUFBWSxHQUFHTixVQUFVLENBQUNPLEtBQTlCOztBQUVBLE1BQUksQ0FBQ04sS0FBRCxZQUFrQk8sZ0JBQXRCLEVBQStCO0FBQzdCQyxJQUFBQSxPQUFPLENBQUNDLElBQVIsS0FBYUMsZ0JBQWIsK05BQ2lETCxFQUFFLElBQUlBLEVBQUUsQ0FBQ00sSUFBVCxJQUFpQmIsR0FEbEUsRUFFZ0NFLEtBQUssQ0FBQ1csSUFGdEM7QUFLQSxXQUFPWixVQUFQO0FBQ0Q7O0FBRUQsTUFDRSxDQUFDQSxVQUFVLENBQUNPLEtBQVosSUFDSVAsVUFBVSxDQUFDYSxHQUFYLElBQWtCYixVQUFVLENBQUNjLEdBQTdCLElBQW9DZCxVQUFVLENBQUNlLFdBRnJELEVBR0U7QUFDQU4sSUFBQUEsT0FBTyxDQUFDQyxJQUFSLEtBQWFDLGdCQUFiLGdWQUNpREwsRUFBRSxJQUFJQSxFQUFFLENBQUNNLElBQVQsSUFBaUJiLEdBRGxFO0FBT0EsV0FBT0MsVUFBUDtBQUNELEdBM0JPLENBNkJSOzs7QUFDQSxTQUFPRixNQUFNLENBQUNDLEdBQUQsQ0FBYjtBQUNBLFNBQU9DLFVBQVUsQ0FBQ08sS0FBbEI7O0FBRUEsTUFBSUYsT0FBSixFQUFhO0FBQ1gsV0FBT0YsS0FBSyxDQUFDSixHQUFELENBQVo7QUFDRCxHQUZELE1BR0s7QUFDSCxXQUFPRSxLQUFLLENBQUNGLEdBQUQsQ0FBWjtBQUNELEdBdENPLENBd0NSO0FBQ0E7OztBQUNBRSxFQUFBQSxLQUFLLENBQUNlLGlCQUFELENBQUwsQ0FBZ0JuQixZQUFoQixJQUFnQ0ksS0FBSyxDQUFDZSxpQkFBRCxDQUFMLENBQWdCbkIsWUFBaEIsS0FBaUMsRUFBakUsQ0ExQ1EsQ0E0Q1I7QUFDQTtBQUNBOztBQUNBLE1BQUlTLEVBQUUsQ0FBQ00sSUFBSCxLQUFZYixHQUFoQixFQUFxQjtBQUNuQmtCLElBQUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQlosRUFBdEIsRUFBMEIsTUFBMUIsRUFBa0M7QUFBRU8sTUFBQUEsR0FBRyxFQUFFLGVBQVc7QUFBRSxlQUFPZCxHQUFQO0FBQVk7QUFBaEMsS0FBbEM7QUFDRCxHQWpETyxDQW1EUjs7O0FBQ0FFLEVBQUFBLEtBQUssQ0FBQ2UsaUJBQUQsQ0FBTCxDQUFnQm5CLFlBQWhCLEVBQThCc0IsSUFBOUIsQ0FBbUNiLEVBQW5DLEVBcERRLENBc0RSOzs7QUFDQU4sRUFBQUEsVUFBVSxDQUFDb0IsTUFBTSxPQUFOLENBQVd2QixZQUFYLENBQUQsQ0FBVixHQUF1Q1MsRUFBdkMsQ0F2RFEsQ0F5RFI7O0FBQ0EsU0FBT04sVUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTcUIsUUFBVCxDQUNMdkIsTUFESyxFQUVMQyxHQUZLLEVBR0xDLFVBSEssRUFJRztBQUNSLFNBQU9KLFFBQVEsQ0FBQyxXQUFELEVBQWNFLE1BQWQsRUFBc0JDLEdBQXRCLEVBQTJCQyxVQUEzQixDQUFmO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNzQixPQUFULENBQ0x4QixNQURLLEVBRUxDLEdBRkssRUFHTEMsVUFISyxFQUlHO0FBQ1IsU0FBT0osUUFBUSxDQUFDLFVBQUQsRUFBYUUsTUFBYixFQUFxQkMsR0FBckIsRUFBMEJDLFVBQTFCLENBQWY7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU3VCLFdBQVQsQ0FDTHpCLE1BREssRUFFTEMsR0FGSyxFQUdMQyxVQUhLLEVBSUc7QUFDUixTQUFPSixRQUFRLENBQUMsY0FBRCxFQUFpQkUsTUFBakIsRUFBeUJDLEdBQXpCLEVBQThCQyxVQUE5QixDQUFmO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG5hbWVzcGFjZSBkZWNvcmF0b3JzICovXG4vKiogQGZsb3cgKi9cblxuaW1wb3J0IHsgR1FMQmFzZSwgTUVUQV9LRVkgfSBmcm9tICcuLi9HUUxCYXNlJ1xuaW1wb3J0IHsgZGVkZW50IH0gZnJvbSAnbmUtdGFnLWZucydcblxuLyoqXG4gKiBTaW5jZSB0aGUgYnVsayBmdW5jdGlvbmFsaXR5IG9mIEBzdWJzY3JpcHRvciwgQG11dGF0b3IgYW5kXG4gKiBAcmVzb2x2ZXIgYXJlIGFsbW9zdCBpZGVudGljYWwsIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbiBzZXJ2ZVxuICogdGhlIGJ1bGsgb2YgdGhlIGZ1bmN0aW9uYWxpdHkgbmVlZGVkIHNpbmNlIHRoZXkgYXJlIHNvIHNpbWlsYXJcbiAqIGluIG5hdHVyZS5cbiAqXG4gKiBAbWV0aG9kIGRlY29yYXRvcnN+ZGVjb3JhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRhUHJvcGVydHkgdGhlIG5hbWUgb2YgdGhlIG1ldGEgc3ViIGtleSB1bmRlciB3aGljaCB0b1xuICogc3RvcmUgdGhlIG1vZGlmaWVkIGRlY29yYXRlZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXQgZWl0aGVyIHRoZSBDbGFzcyBpdHNlbGYsIGlmIGRlZmluZWRcbiAqIG9uIGEgc3RhdGljIG1ldGhvZCwgb3IgdGhlIHByb3RvdHlwZSBpZiBkZWZpbmVkIG9uIGFuIGluc3RhbmNlIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgZGVjb3JhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBhIGRlY29yYXRvciBkZXNjcmlwdG9yOyBzZWVcbiAqIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRlc2NyaXB0b3JzXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRlKFxuICBtZXRhUHJvcGVydHk6IHN0cmluZyxcbiAgdGFyZ2V0OiBPYmplY3QgfCBGdW5jdGlvbixcbiAga2V5OiBzdHJpbmcsXG4gIGRlc2NyaXB0b3I6IE9iamVjdFxuKTogT2JqZWN0IHtcbiAgY29uc3QgQ2xhc3MgPSB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gdGFyZ2V0IDogdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBjb25zdCBwcm90byA9IHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBjb25zdCBpc0NsYXNzID0gQ2xhc3MgPT09IHRhcmdldDtcbiAgbGV0IGZuOiBGdW5jdGlvbiA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKCFDbGFzcyBpbnN0YW5jZW9mIEdRTEJhc2UpIHtcbiAgICBjb25zb2xlLndhcm4oZGVkZW50YFxuICAgICAgSWdub3JpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIEByZXNvbHZlciBmb3IgJHtmbiAmJiBmbi5uYW1lIHx8IGtleX0uXG4gICAgICBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgJHtDbGFzcy5uYW1lfSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgR1FMQmFzZS5cbiAgICBgKVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JcbiAgfVxuXG4gIGlmIChcbiAgICAhZGVzY3JpcHRvci52YWx1ZVxuICAgIHx8IChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCB8fCBkZXNjcmlwdG9yLmluaXRpYWxpemVyKVxuICApIHtcbiAgICBjb25zb2xlLndhcm4oZGVkZW50YFxuICAgICAgSWdub3JpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIEByZXNvbHZlciBmb3IgJHtmbiAmJiBmbi5uYW1lIHx8IGtleX0uIFRoZVxuICAgICAgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgaXQgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCB0byBhIHN0YXRpYyBvciBpbnN0YW5jZVxuICAgICAgbWV0aG9kIG9mIGEgY2xhc3MuIEl0IGlzIG5vdCB2YWxpZCB0byBhcHBseSB0aGlzIHRvIGEgZ2V0dGVyLCBzZXR0ZXIsXG4gICAgICBvciBwcm9wZXJ0eS5cbiAgICBgKVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZnVuY3Rpb24gZnJvbSB3aGVyZXZlciBpdCBoYXBwZW5zIHRvIGJlIGRlZmluZWQuXG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgZGVsZXRlIGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKGlzQ2xhc3MpIHtcbiAgICBkZWxldGUgcHJvdG9ba2V5XVxuICB9XG4gIGVsc2Uge1xuICAgIGRlbGV0ZSBDbGFzc1trZXldXG4gIH1cblxuICAvLyBPYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIG1ldGFkYXRhIHN0b3JhZ2UgYXJlYSBhbmQgY3JlYXRlIHRoZSByZXNvbHZlclxuICAvLyBwb3J0aW9uIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cbiAgQ2xhc3NbTUVUQV9LRVldW21ldGFQcm9wZXJ0eV0gPSBDbGFzc1tNRVRBX0tFWV1bbWV0YVByb3BlcnR5XSB8fCBbXVxuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBmdW5jdGlvbiBuYW1lIG1hdGNoZXMgdGhlIGtleSwgaWYgbm90LCB3cmFwIGl0XG4gIC8vIHN1Y2ggdGhhdCBmdXR1cmUgdXNlcyBvZiB0aGUgLm5hbWUgcHJvcGVydHkgbWF0Y2ggdGhlIGtleSBvZiB0aGVcbiAgLy8gZGVjb3JhdGVkIGZ1bmN0aW9uXG4gIGlmIChmbi5uYW1lICE9PSBrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ga2V5IH0gfSlcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSBrZXkgYnkgbmFtZSwgb3ZlcndyaXR0aW5nIGlmIG5lY2Vzc2FyeSwgYW5kIGFzc2lnbiB0aGUgZnVuY3Rpb25cbiAgQ2xhc3NbTUVUQV9LRVldW21ldGFQcm9wZXJ0eV0ucHVzaChmbilcblxuICAvLyBQYXNzIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gYWxvbmcgZm9yIG90aGVycyB0byBjb25zdW1lXG4gIGRlc2NyaXB0b3JbU3ltYm9sLmZvcihtZXRhUHJvcGVydHkpXSA9IGZuXG5cbiAgLy8gUmV0dXJuIGEgbmV3IGRlY29yYXRvciBkZXNjcmlwdG9yIHdpdGhvdXQgdGhlIHZhbHVlIGZ1bmN0aW9uXG4gIHJldHVybiBkZXNjcmlwdG9yO1xufVxuXG4vKipcbiAqIFRoZSByZXNvbHZlciBmdW5jdGlvbiBzaG91bGQgcGVyZm9ybSB0aGUgbmVjZXNzYXJ5IGluc2VydGlvbiB0byBwbGFjZVxuICogdGhlIGRlY29yYXRlZCBmdW5jdGlvbiBpbiBxdWVzdGlvbiBpbnRvIGEgcGxhY2UgdGhhdCBpdCBjYW4gYmUgbWVyZ2VkXG4gKiB3aXRoIHRoZSBmaW5hbCBsaXN0IG9mIHF1ZXJ5IHJlc29sdmVycy4gVHlwaWNhbGx5IGEgcmVzb2x2ZXIgZnVuY3Rpb24sXG4gKiBhcyBkZWZpbmVkIGluIGBSRVNPTFZFUlMoKWAgcmVjZWl2ZXMgYSBgcmVxdWVzdERhdGFgIG9iamVjdC4gRnVuY3Rpb25zXG4gKiBkZWNvcmF0ZWQgd2l0aCBgQHJlc29sdmVyYCByZWNlaXZlIHRoaXMgYXMgdGhlaXIgZmlyc3QgcGFyYW1ldGVyLiBDb2RlXG4gKiBhY2NvcmRpbmdseS5cbiAqXG4gKiBAbWV0aG9kIPCfj7fioIBkZWNvcmF0b3JzfnJlc29sdmVyXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0IGVpdGhlciB0aGUgQ2xhc3MgaXRzZWxmLCBpZiBkZWZpbmVkXG4gKiBvbiBhIHN0YXRpYyBtZXRob2QsIG9yIHRoZSBwcm90b3R5cGUgaWYgZGVmaW5lZCBvbiBhbiBpbnN0YW5jZSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGJlaW5nIGRlY29yYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgYSBkZWNvcmF0b3IgZGVzY3JpcHRvcjsgc2VlXG4gKiBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXNjcmlwdG9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZXIoXG4gIHRhcmdldDogT2JqZWN0IHwgRnVuY3Rpb24sXG4gIGtleTogc3RyaW5nLFxuICBkZXNjcmlwdG9yOiBPYmplY3Rcbik6IE9iamVjdCB7XG4gIHJldHVybiBkZWNvcmF0ZSgncmVzb2x2ZXJzJywgdGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpXG59XG5cbi8qKlxuICogVGhlIG11dGF0b3IgZnVuY3Rpb24gc2hvdWxkIHBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBpbnNlcnRpb24gdG8gcGxhY2VcbiAqIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gaW4gcXVlc3Rpb24gaW50byBhIHBsYWNlIHRoYXQgaXQgY2FuIGJlIG1lcmdlZFxuICogd2l0aCB0aGUgZmluYWwgbGlzdCBvZiBxdWVyeSByZXNvbHZlcnMuIFR5cGljYWxseSBhIG11dGF0b3IgZnVuY3Rpb24sXG4gKiBhcyBkZWZpbmVkIGluIGBSRVNPTFZFUlMoKWAgcmVjZWl2ZXMgYSBgcmVxdWVzdERhdGFgIG9iamVjdC4gRnVuY3Rpb25zXG4gKiBkZWNvcmF0ZWQgd2l0aCBgQG11dGF0b3JgIHJlY2VpdmUgdGhpcyBhcyB0aGVpciBmaXJzdCBwYXJhbWV0ZXIuIENvZGVcbiAqIGFjY29yZGluZ2x5LlxuICpcbiAqIEBtZXRob2Qg8J+Pt+KggGRlY29yYXRvcnN+bXV0YXRvclxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldCBlaXRoZXIgdGhlIENsYXNzIGl0c2VsZiwgaWYgZGVmaW5lZFxuICogb24gYSBzdGF0aWMgbWV0aG9kLCBvciB0aGUgcHJvdG90eXBlIGlmIGRlZmluZWQgb24gYW4gaW5zdGFuY2UgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBkZWNvcmF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIGEgZGVjb3JhdG9yIGRlc2NyaXB0b3I7IHNlZVxuICogYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVzY3JpcHRvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGF0b3IoXG4gIHRhcmdldDogT2JqZWN0IHwgRnVuY3Rpb24sXG4gIGtleTogc3RyaW5nLFxuICBkZXNjcmlwdG9yOiBPYmplY3Rcbik6IE9iamVjdCB7XG4gIHJldHVybiBkZWNvcmF0ZSgnbXV0YXRvcnMnLCB0YXJnZXQsIGtleSwgZGVzY3JpcHRvcilcbn1cblxuLyoqXG4gKiBUaGUgc3Vic2NyaXB0b3IgZnVuY3Rpb24gc2hvdWxkIHBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBpbnNlcnRpb24gdG8gcGxhY2VcbiAqIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gaW4gcXVlc3Rpb24gaW50byBhIHBsYWNlIHRoYXQgaXQgY2FuIGJlIG1lcmdlZFxuICogd2l0aCB0aGUgZmluYWwgbGlzdCBvZiBxdWVyeSByZXNvbHZlcnMuIFR5cGljYWxseSBhIHN1YnNjcmlwdG9yIGZ1bmN0aW9uLFxuICogYXMgZGVmaW5lZCBpbiBgUkVTT0xWRVJTKClgIHJlY2VpdmVzIGEgYHJlcXVlc3REYXRhYCBvYmplY3QuIEZ1bmN0aW9uc1xuICogZGVjb3JhdGVkIHdpdGggYEBzdWJzY3JpcHRvcmAgcmVjZWl2ZSB0aGlzIGFzIHRoZWlyIGZpcnN0IHBhcmFtZXRlci5cbiAqIENvZGUgYWNjb3JkaW5nbHkuXG4gKlxuICogQG1ldGhvZCDwn4+34qCAZGVjb3JhdG9yc35zdWJzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldCBlaXRoZXIgdGhlIENsYXNzIGl0c2VsZiwgaWYgZGVmaW5lZFxuICogb24gYSBzdGF0aWMgbWV0aG9kLCBvciB0aGUgcHJvdG90eXBlIGlmIGRlZmluZWQgb24gYW4gaW5zdGFuY2UgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBkZWNvcmF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIGEgZGVjb3JhdG9yIGRlc2NyaXB0b3I7IHNlZVxuICogYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVzY3JpcHRvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmlwdG9yKFxuICB0YXJnZXQ6IE9iamVjdCB8IEZ1bmN0aW9uLFxuICBrZXk6IHN0cmluZyxcbiAgZGVzY3JpcHRvcjogT2JqZWN0XG4pOiBPYmplY3Qge1xuICByZXR1cm4gZGVjb3JhdGUoJ3N1YnNjcmlwdG9ycycsIHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKVxufVxuIl19