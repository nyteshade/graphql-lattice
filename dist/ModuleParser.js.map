{"version":3,"sources":["../es6/ModuleParser.js"],"names":["types","readdirAsync","fs","readdir","statAsync","stat","typeOf","isString","isOfType","isPrimitive","isArray","isObject","extendsFrom","ModuleParser","constructor","directory","options","addLatticeTypes","path","resolve","classes","skipped","valid","statSync","isDirectory","error","importClass","filePath","moduleContents","yellow","clear","require","ignore","test","extname","ll","log","buffer","readFileSync","looseGraphQL","push","toString","trace","set","findGQLBaseClasses","contents","gqlDefinitions","stack","add","key","value","GQLBase","has","delete","parse","modules","files","opts","Error","walk","map","file","mod","reduce","last","cur","concat","forEach","Class","sort","l","r","name","GQLJSON","failOnError","size","printSkipped","parseSync","walkSync","outWrite","basename","message","replace","dir","filelist","extensions","exts","checkForPackageExtensions","pattern","arrayToPattern","stats","join","flags","RegExp","pkg","packageExts","Array"],"mappings":"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","file":"ModuleParser.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport fs, { readdirSync, statSync } from 'fs'\nimport path from 'path'\nimport * as types from 'ne-types'\nimport { GQLBase } from './GQLBase'\nimport { GQLJSON } from './types/GQLJSON'\nimport { merge } from 'lodash'\nimport {\n  promisify,\n  Deferred,\n  getLatticePrefs,\n  LatticeLogs as ll\n} from './utils'\n\n// Promisify some bits\nconst readdirAsync = promisify(fs.readdir)\nconst statAsync = promisify(fs.stat)\n\n// Fetch some type checking bits from 'types'\nconst {\n  typeOf,\n  isString,\n  isOfType,\n  isPrimitive,\n  isArray,\n  isObject,\n  extendsFrom\n} = types;\n\n/**\n * The ModuleParser is a utility class designed to loop through and iterate\n * on a directory and pull out of each .js file found, any classes or exports\n * that extend from GQLBase or a child of GQLBase.\n *\n * @class ModuleParser\n * @since 2.7.0\n */\nexport class ModuleParser {\n  /**\n   * An internal array of `GQLBase` extended classes found during either a\n   * `parse()` or `parseSync()` call.\n   *\n   * @memberof ModuleParser\n   * @type {Array<GQLBase>}\n   */\n  classes: Array<GQLBase>;\n\n  /**\n   * An array of strings holding loose GraphQL schema documents.\n   *\n   * @memberof ModuleParser\n   * @type {Array<string>}\n   */\n  looseGraphQL: Array<string> = [];\n\n  /**\n   * A map of skipped items on the last pass and the associated error that\n   * accompanies it.\n   */\n  skipped: Map<string, Error>;\n\n  /**\n   * A string denoting the directory on disk where `ModuleParser` should be\n   * searching for its classes.\n   *\n   * @memberof ModuleParser\n   * @type {string}\n   */\n  directory: string;\n\n  /**\n   * A boolean value denoting whether or not the `ModuleParser` instance is\n   * valid; i.e. the directory it points to actually exists and is a directory\n   *\n   * @type {boolean}\n   */\n  valid: boolean;\n\n  /**\n   * An object, optionally added during construction, that specifies some\n   * configuration about the ModuleParser and how it should do its job.\n   *\n   * Initially, the\n   *\n   * @type {Object}\n   */\n  options: Object = {};\n\n  /**\n   * The constructor\n   *\n   * @constructor\n   * @method ⎆⠀constructor\n   * @memberof ModuleParser\n   * @inner\n   *\n   * @param {string} directory a string path to a directory containing the\n   * various GQLBase extended classes that should be gathered.\n   */\n  constructor(directory: string, options: Object = {addLatticeTypes: true}) {\n    this.directory = path.resolve(directory);\n    this.classes = [];\n    this.skipped = new Map();\n\n    merge(this.options, options);\n\n    try {\n      this.valid = fs.statSync(directory).isDirectory();\n    }\n    catch (error) {\n      this.valid = false;\n    }\n  }\n\n  /**\n   * Given a file path, this method will attempt to import/require the\n   * file in question and return the object it exported; whatever that\n   * may be.\n   *\n   * @method ModuleParser#⌾⠀importClass\n   * @since 2.7.0\n   *\n   * @param {string} filePath a path to pass to `require()`\n   *\n   * @return {Object} the object, or undefined, that was returned when\n   * it was `require()`'ed.\n   */\n  importClass(filePath: string): Object {\n    let moduleContents: Object = {};\n    let yellow: string = '\\x1b[33m'\n    let clear: string = '\\x1b[0m'\n\n    try {\n      moduleContents = require(filePath)\n    }\n    catch(ignore) {\n      if (/\\.graphql/i.test(path.extname(filePath))) {\n        ll.log(`Ingesting .graphql file ${filePath}`)\n        let buffer = fs.readFileSync(filePath)\n        this.looseGraphQL.push(fs.readFileSync(filePath).toString())\n      }\n      else {\n        ll.log(`${yellow}Skipping${clear} ${filePath}`)\n        ll.trace(ignore)\n        this.skipped.set(filePath, ignore)\n      }\n    }\n\n    return moduleContents;\n  }\n\n  /**\n   * Given an object, typically the result of a `require()` or `import`\n   * command, iterate over its contents and find any `GQLBase` derived\n   * exports. Continually, and recursively, build this list of classes out\n   * so that we can add them to a `GQLExpressMiddleware`.\n   *\n   * @method ModuleParser#⌾⠀findGQLBaseClasses\n   * @since 2.7.0\n   *\n   * @param {Object} contents the object to parse for properties extending\n   * from `GQLBase`\n   * @param {Array<GQLBase>} gqlDefinitions the results, allowed as a second\n   * parameter during recursion as a means to save state between calls\n   * @return {Set<mixed>} a unique set of values that are currently being\n   * iterated over. Passed in as a third parameter to save state between calls\n   * during recursion.\n   */\n  findGQLBaseClasses(\n    contents: Object,\n    gqlDefinitions?: Array<GQLBase> = [],\n    stack?: Set<GQLBase> = new Set()\n  ): Array<GQLBase> {\n    // In order to prevent infinite object recursion, we should add the\n    // object being iterated over to our Set. At each new recursive level\n    // add the item being iterated over to the set and only recurse into\n    // if the item does not already exist in the stack itself.\n    stack.add(contents)\n\n    for (let key in contents) {\n      let value = contents[key];\n\n      if (isPrimitive(value)) { continue }\n\n      if (extendsFrom(value, GQLBase)) {\n        gqlDefinitions.push(value)\n      }\n\n      if ((isObject(value) || isArray(value)) && !stack.has(value)) {\n        gqlDefinitions = this.findGQLBaseClasses(value, gqlDefinitions, stack);\n      }\n    }\n\n    // We remove the current iterable from our set as we leave this current\n    // recursive iteration.\n    stack.delete(contents)\n\n    return gqlDefinitions\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   * in a resolved promise.\n   *\n   * @method ModuleParser#⌾⠀parse\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Promise<Array<GQLBase>>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  async parse(): Promise<Array<GQLBase>> {\n    let modules\n    let files\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    // @ComputedType\n    files = await this.constructor.walk(this.directory)\n    modules = files.map(file => this.importClass(file))\n\n    // @ComputedType\n    (modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class)))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   *\n   * @method ModuleParser#⌾⠀parseSync\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Array<GQLBase>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  parseSync(): Array<GQLBase> {\n    let modules: Array<Object>;\n    let files: Array<string>;\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    files = this.constructor.walkSync(this.directory)\n    modules = files.map(file => {\n      return this.importClass(file)\n    })\n\n    modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * Prints the list of skipped files, their stack traces, and the errors\n   * denoting the reasons the files were skipped.\n   */\n  printSkipped() {\n    if (this.skipped.size) {\n      ll.outWrite('\\x1b[1;91m')\n      ll.outWrite('Skipped\\x1b[0;31m the following files\\n')\n\n      for (let [key, value] of this.skipped) {\n        ll.log(`${path.basename(key)}: ${value.message}`)\n        if (value.stack)\n          ll.log(value.stack.replace(/(^)/m, '$1  '))\n      }\n\n      ll.outWrite('\\x1b[0m')\n    }\n    else {\n      ll.log('\\x1b[1;32mNo files skipped\\x1b[0m')\n    }\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory.\n   *\n   * @method ModuleParser~⌾⠀walk\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Promise<Array<string>>} an array of existing absolute file paths\n   * found under the supplied `dir` directory.\n   */\n  static async walk(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Promise<Array<string>> {\n    let files = await readdirAsync(dir);\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = await statAsync(file)\n      if (stats.isDirectory()) {\n        filelist = await this.walk(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory. This version does this in a\n   * synchronous fashion.\n   *\n   * @method ModuleParser~⌾⠀walkSync\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Array<string>} an array of existing absolute file paths found\n   * under the supplied `dir` directory.\n   */\n  static walkSync(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Array<string> {\n    let files = readdirSync(dir)\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = statSync(file)\n      if (stats.isDirectory()) {\n        filelist = this.walkSync(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * The ModuleParser should only parse files that match the default or\n   * supplied file extensions. The default list contains .js, .jsx, .ts\n   * and .tsx; so JavaScript or TypeScript files and their JSX React\n   * counterparts\n   *\n   * Since the list is customizable for a usage, however, it makes sense\n   * to have a function that will match what is supplied rather than\n   * creating a constant expression to use instead.\n   *\n   * @static\n   * @memberof ModuleParser\n   * @function ⌾⠀arrayToPattern\n   * @since 2.13.0\n   *\n   * @param {Array<string>} extensions an array of extensions to\n   * convert to a regular expression that would pass for each\n   * @param {string} flags the value passed to a new RegExp denoting the\n   * flags used in the pattern; defaults to 'i' for case insensitivity\n   * @return {RegExp} a regular expression object matching the contents\n   * of the array of extensions or the default extensions and that will\n   * also match those values in a case insensitive manner\n   */\n  static arrayToPattern(\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx'],\n    flags: string = 'i'\n  ) {\n    return new RegExp(\n      extensions\n        .join('|')\n        .replace(/\\./g, '\\\\.')\n        .replace(/([\\|$])/g, '\\\\b$1'),\n      flags\n    )\n  }\n\n  /**\n   * Using the module `read-pkg-up`, finds the nearest package.json file\n   * and checks to see if it has a `.lattice.moduleParser.extensions'\n   * preference. If so, if the value is an array, that value is used,\n   * otherwise the value is wrapped in an array. If the optional parameter\n   * `toString` is `true` then `.toString()` will be invoked on any non\n   * Array values found; this behavior is the default\n   *\n   * @static\n   * @memberof ModuleParser\n   * @method ⌾⠀checkForPackageExtensions\n   * @since 2.13.0\n   *\n   * @param {boolean} toString true if any non-array values should have\n   * their `.toString()` method invoked before being wrapped in an Array;\n   * defaults to true\n   * @return {?Array<string>} null if no value is set for the property\n   * `lattice.ModuleParser.extensions` in `package.json` or the value\n   * of the setting if it is an array. Finally if the value is set but is\n   * not an array, the specified value wrapped in an array is returned\n   */\n  static checkForPackageExtensions(toString: boolean = true): ?Array<string> {\n    let pkg = getLatticePrefs()\n    let extensions = null\n\n    if (pkg.ModuleParser && pkg.ModuleParser.extensions) {\n      let packageExts = pkg.ModuleParser.extensions\n\n      if (Array.isArray(packageExts)) {\n        extensions = packageExts\n      }\n      else {\n        extensions = [toString ? packageExts.toString() : packageExts]\n      }\n    }\n\n    return extensions\n  }\n}\n\nexport default ModuleParser;\n"]}